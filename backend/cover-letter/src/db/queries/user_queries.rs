use lettre::Address;
use sqlx::{Acquire, Executor, Postgres};
// use std::path::{Path, PathBuf};
// use strum_macros::{Display, EnumString};
use crate::model::{SessionTokenHash, SubscriptionStatus, UserId};
use std::str::FromStr;

// rewrite the count_users function to use postgresql syntax instead of sqlite syntax
//
pub async fn count_users(exec: impl Executor<'_, Database = Postgres>) -> usize {
    let qr = sqlx::query! {"
        SELECT COUNT(*) AS user_count FROM user_table;
    "}
    .fetch_one(exec)
    .await
    .unwrap();

    qr.user_count.unwrap().try_into().unwrap()
    // let's fix this error:
}

pub async fn insert_user_interest(email: &Address, exec: impl Executor<'_, Database = Postgres>) {
    let email = email.to_string();
    sqlx::query! {"
        INSERT INTO user_interest (email) VALUES ($1) ON CONFLICT (email) DO NOTHING;
    ", email}
    .execute(exec)
    .await
    .unwrap();
}

/// Creates a new user with a mail.
///
/// Returns the [UserId] of the new user or None if a user with this email address exists already.
pub async fn insert_user(
    email: &Address,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<Option<UserId>, sqlx::Error> {
    let email = email.to_string();

    let option_user_id: Option<UserId> = sqlx::query_as!(
        UserId,
        r#"
        INSERT INTO user_table (email) VALUES ($1) ON CONFLICT (email) DO NOTHING RETURNING user_id;
        "#,
        email
    )
    .fetch_optional(exec)
    .await?;
    Ok(option_user_id)
}

pub async fn update_user_email(
    UserId { user_id }: UserId,
    email: &Address,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<Option<UserId>, sqlx::Error> {
    let email = email.to_string();
    let update_result = sqlx::query! {"
        UPDATE user_table SET email = $1 WHERE user_id = $2 RETURNING user_id;
    ", email, user_id}
    .fetch_one(exec)
    .await;
    match update_result {
        Ok(_) => Ok(Some(UserId { user_id })),
        Err(sqlx::Error::Database(db_err)) => {
            if db_err.is_unique_violation() {
                Ok(None)
            } else {
                Err(sqlx::Error::Database(db_err))
            }
        }
        Err(err) => Err(err),
    }
}

pub async fn merge_users(
    primary_user_id: UserId,
    secondary_user_id: UserId,
    tx: &mut sqlx::Transaction<'_, sqlx::Postgres>,
) -> Result<(), sqlx::Error> {
    // List of tables in the correct order based on foreign key dependencies
    let tables = [
        "application",
        "resume",
        "template_cover_letter",
        "session",
        "signin_pending",
        "privacy_consent",
        "feedback",
        "signup_confirmation_pending",
        "signup_confirmation",
    ];

    for table in &tables {
        // Create checkpoint of transaction to roll back to in case the UPDATE statement fails:
        let mut inner_tx = tx.begin().await?;
        let sql = format!("UPDATE {} SET user_id = $1 WHERE user_id = $2", table);
        let update_result = sqlx::query(&sql)
            .bind(primary_user_id.user_id)
            .bind(secondary_user_id.user_id)
            .execute(&mut *inner_tx)
            .await;

        match update_result {
            Ok(_) => {
                inner_tx.commit().await?;
            }
            // We have removed the UNIQUE CONSTRAINTs for resume and template_cover_letter
            // to avoid having to recursively handle foreign key dependencies.
            // Therefore we don't need to handle unique violations here.
            //
            // If the error is a unique violation, we need to delete the row in the table
            // to remove the duplicate entry
            // Err(sqlx::Error::Database(db_err)) if db_err.is_unique_violation() => {
            //     inner_tx.rollback().await?;
            //     let delete_sql = format!(
            //         "DELETE FROM {} WHERE user_id = $1",
            //         table
            //     );
            //     sqlx::query(&delete_sql)
            //         .bind(secondary_user_id.user_id)
            //         .execute(&mut **tx)
            //         .await?;
            //     return Err(sqlx::Error::Database(db_err));
            // }
            Err(err) => {
                return Err(err);
            }
        }
    }

    // Delete the secondary user
    sqlx::query!(
        "DELETE FROM user_table WHERE user_id = $1",
        secondary_user_id.user_id
    )
    .execute(&mut **tx)
    .await?;

    Ok(())
}

pub async fn insert_anonymous_user(
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<UserId, sqlx::Error> {
    // insert empty user to trigger the autogenerated user_id
    sqlx::query_as! {
        UserId,
        r#"
        INSERT INTO user_table
        DEFAULT VALUES
        RETURNING user_id;
        "#,
    }
    .fetch_one(exec)
    .await
}

/// Returns the [UserId] of a user given his email.
pub async fn get_user(
    email: &str,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<Option<UserId>, sqlx::Error> {
    // fix this sqlx query to use postgresql syntax instead of sqlite syntax and fetch_optional instead of fetch_one
    sqlx::query_as!(
        UserId,
        r#"
        SELECT user_id FROM user_table WHERE email = $1;
        "#,
        email
    )
    .fetch_optional(exec)
    .await
}

pub async fn get_user_by_stripe_customer_id(
    stripe_customer_id: &stripe::CustomerId,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<Option<UserId>, sqlx::Error> {
    let qr = sqlx::query! {"
        SELECT user_id FROM user_table WHERE stripe_customer_id = $1;
    ", stripe_customer_id.as_str() }
    .fetch_optional(exec)
    .await?;
    match qr {
        Some(qr) => Ok(Some(UserId {
            user_id: qr.user_id,
        })),
        None => Ok(None),
    }
}

pub async fn get_stripe_customer_id(
    user_id: &UserId,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<Option<stripe::CustomerId>, sqlx::Error> {
    let qr = sqlx::query! {"
        SELECT stripe_customer_id FROM user_table WHERE user_id = $1;
    ", user_id.user_id }
    .fetch_optional(exec)
    .await?;
    match qr {
        Some(qr) => match qr.stripe_customer_id {
            Some(stripe_customer_id) => {
                let stripe_customer_id = stripe::CustomerId::from_str(&stripe_customer_id).unwrap();
                Ok(Some(stripe_customer_id))
            }
            None => Ok(None),
        },
        None => Ok(None),
    }
}

pub async fn set_stripe_customer_id(
    user_id: &UserId,
    stripe_customer_id: &stripe::CustomerId,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<(), sqlx::Error> {
    sqlx::query! {"
        UPDATE user_table SET stripe_customer_id = $1 WHERE user_id = $2;
    ", stripe_customer_id.as_str(), user_id.user_id }
    .execute(exec)
    .await?;
    Ok(())
}

/// Returns the email address of a user given his [UserId].
pub async fn get_email_address(
    UserId { user_id }: UserId,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<Option<Address>, sqlx::Error> {
    let qr = sqlx::query! {"
        SELECT email FROM user_table WHERE user_id = $1;
        ", user_id }
    .fetch_optional(exec)
    .await?;
    match qr {
        Some(qr) => match qr.email {
            Some(email) => {
                let email = Address::from_str(&email).unwrap();
                Ok(Some(email))
            }
            None => Ok(None),
        },
        None => Ok(None),
    }
}

/// Records that a given user has consented to the privacy policy.
pub async fn record_consent(
    UserId { user_id }: UserId,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<(), sqlx::Error> {
    // fix this sqlx query to use postgresql syntax instead of sqlite syntax
    sqlx::query! {"
        INSERT INTO privacy_consent (user_id) VALUES ($1);
    ", user_id }
    .execute(exec)
    .await?;
    Ok(())
}

pub struct SignupConfirmationToken(pub String);

pub async fn add_signup_confirmation_token(
    UserId { user_id }: UserId,
    token: &SignupConfirmationToken,
    exec: impl Executor<'_, Database = Postgres>,
) {
    // fix this sqlx query to use postgresql syntax instead of sqlite syntax and query_as if appropriate
    sqlx::query! {"
        INSERT INTO signup_confirmation_pending (user_id, token) VALUES ($1, $2);
    ", user_id, token.0}
    .execute(exec)
    .await
    .unwrap();
}

// convert the FlatSignupConfirmationPending to SignupConfirmationPending
// impl From<FlatSignupConfirmationPending> for SignupConfirmationPending {
//     fn from(flat: FlatSignupConfirmationPending) -> Self {
//         let FlatSignupConfirmationPending { user_id, created_at } = flat;
//         Self {
//             user_id: UserId { user_id },
//             created_at,
//         }
//     }
// }

#[derive(sqlx::FromRow)]
pub struct SignupConfirmationPending {
    #[sqlx(flatten)]
    pub user_id: UserId,
    pub created_at: chrono::DateTime<chrono::Local>,
}
pub async fn get_signup_confirmation_pending(
    token: &SignupConfirmationToken,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<Option<SignupConfirmationPending>, sqlx::Error> {
    // use query_as macro:
    sqlx::query_as!(
        SignupConfirmationPending,
        r#"
        SELECT user_id, created_at FROM signup_confirmation_pending WHERE token = $1;
        "#,
        token.0
    )
    .fetch_optional(exec)
    .await
}

pub async fn add_signup_confirmation(
    UserId { user_id }: UserId,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<(), sqlx::Error> {
    // fix this sqlx query to use postgresql syntax instead of sqlite syntax
    sqlx::query! {"
        INSERT INTO signup_confirmation (user_id) VALUES ($1);
    ", user_id }
    .execute(exec)
    .await?;
    Ok(())
}

pub async fn add_session(
    UserId { user_id }: UserId,
    token_hash: &SessionTokenHash,
    exec: impl Executor<'_, Database = Postgres>,
) {
    // fix this sqlx query to use postgresql syntax instead of sqlite syntax
    // and query_as if appropriate
    sqlx::query! {"
        INSERT INTO session
        (user_id, token_hash)
        VALUES ($1, $2);
    ",
    user_id,
    token_hash.0,
    }
    .execute(exec)
    .await
    .unwrap();
}

pub struct SessionFromDatabase {
    pub user_id: UserId,
    pub created_at: chrono::DateTime<chrono::Local>,
}

pub async fn get_session(
    token_hash: &SessionTokenHash,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<Option<SessionFromDatabase>, sqlx::Error> {
    sqlx::query_as!(
        SessionFromDatabase,
        r#"
        SELECT
            user_id,
            created_at
        FROM session
        WHERE token_hash = $1;
        "#,
        token_hash.0
    )
    .fetch_optional(exec)
    .await
}

pub async fn delete_session(
    token_hash: &SessionTokenHash,
    exec: impl Executor<'_, Database = Postgres>,
) {
    sqlx::query! {"
        DELETE FROM session WHERE token_hash = $1;
    ", token_hash.0}
    .execute(exec)
    .await
    .unwrap();
}

pub struct SigninToken(pub String);

pub async fn add_signin_pending(
    UserId { user_id }: UserId,
    token: &SigninToken,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<(), sqlx::Error> {
    sqlx::query! {"
        INSERT INTO signin_pending (user_id, token) VALUES ($1, $2);
    ", user_id, token.0}
    .execute(exec)
    .await?;
    Ok(())
}

#[derive(sqlx::FromRow)]
pub struct SigninPending {
    #[sqlx(flatten)]
    pub user_id: UserId,
    pub created_at: chrono::DateTime<chrono::Local>,
}

pub async fn get_signin_pending(
    token: &SigninToken,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<Option<SigninPending>, sqlx::Error> {
    sqlx::query_as!(
        SigninPending,
        r#"
        SELECT user_id, created_at FROM signin_pending WHERE token = $1;
        "#,
        token.0
    )
    .fetch_optional(exec)
    .await
}

pub async fn get_subscription_status(
    UserId { user_id }: UserId,
    exec: impl Executor<'_, Database = Postgres>,
) -> Result<Option<SubscriptionStatus>, sqlx::Error> {
    let status = sqlx::query!(
        r#"
        SELECT subscription_status as "subscription_status: String"
        FROM user_table
        WHERE user_id = $1;
        "#,
        user_id
    )
    .fetch_one(exec)
    .await?;
    match status.subscription_status.as_deref() {
        Some("Active") => Ok(Some(SubscriptionStatus::Active)),
        Some("Inactive") => Ok(Some(SubscriptionStatus::Inactive)),
        _ => Ok(None),
    }
}
